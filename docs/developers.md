# Information for component developers

## Introduction

The SDK is based on EcmaScript 6 (ES6). It uses babelify to translate to ES5.
It is based on OpenLayers, React 15 and Flux.
For the user interface, material-ui React components are used. See http://www.material-ui.com for more information.
For internationalization, Yahoo's react-intl (v2) is used.
Node and npm are used as the development environment.

## React

Component API (e.g. ```componentWillMount```, ```componentWillUnmount```) is important to know about.
Components have properties (```this.props```), more like configuration options.
Components have state (```this.state```), and on change of state (```setState```) they are re-rendered.
React uses a virtual DOM, so it can diff the changes and only apply those (for performance reasons).
Render method needs to return single root (```<article>``` can e.g. be used as workaround).
To pass on all properties to a child component use: ```{...this.props}```.
Define ```propTypes``` static on the class, for example: ```static propTypes = { charts: React.PropTypes.array.isRequired };```.

## JSX

JSX is an XML like syntax to create components. For example:

```html
<Component property1={variable1} />
```

It can be nested, and can be mixed with normal HTML.
You can use the ref property instead of the HTML id (```ref='map'``` in JSX and then ```this.refs.map``` in code).
Babelify will transform this to regular javascript.

## Flux

Flux means uni-directional flow of data.
A dispatched change needs to be handled, before another one can commence.
It has concepts such as stores, actions, dispatchers.
This is internal to the SDK, the app developer should not need to know too much about it.
The store extends the standard EventEmitter class.
Stores should be singletons.
We use a central application dispatcher that extends Flux’s Dispatcher.
Actions are functions that ask the dispatcher to handle certain actions (using constants).
Components (or stores) can register listeners from actions on the dispatcher. An example:

```javascript
AppDispatcher.register((payload) => {
  let action = payload.action;
  switch(action.type) {
    case SelectConstants.SELECT_FEATURES_IN:
      // do something
      break;
    default:
      break;
  }
});
```

## Internationalisation (i18n)

At the component level:

```javascript
import {defineMessages, injectIntl, intlShape} from ‘react-intl';

const messages = defineMessages({
  buttontitle: {
    id: 'homebutton.buttontitle',
    description: 'Title for the home button',
    defaultMessage: 'Home'
  }
});

class HomeButton extends React.Component {
  render() {
    const {formatMessage} = this.props.intl;
    return (
      <button title={formatMessage(messages.buttontitle)} />
    );
  }
}

HomeButton.propTypes = {
 intl: intlShape.isRequired
};

export default injectIntl(HomeButton);
```

At the application level:

```javascript
import {addLocaleData, IntlProvider} from ‘react-intl';
import enLocaleData from 'react-intl/dist/locale-data/en';
import enMessages from '@boundlessgeo/sdk/locale/en';

addLocaleData(
  enLocaleData
);

ReactDOM.render(<IntlProvider locale='en' messages={enMessages}><App /></IntlProvider>, document.getElementById('main'));
```

We use the babel-plugin-react-intl to extract messages from source code.
It generates JSON files per component.
```npm run i18n``` generates i18n template for all components in ```locale/en.js```
In ```.babelrc``` this is activated with:

```json
  "plugins": [
    ["react-intl", {
        "messagesDir": "./build/messages/",
        "enforceDescriptions": true
    }]
  ]
```

## API docs

Uses ```react-docgen```, which reads a documentation block on top of the class and a documentation block on top of each prop.
```npm run generate:docs``` will generate the API docs.

## CSS

Two approaches are used:

  * dr-frankenstyle
  * cssify (browserify transform)

### dr-frankenstyle

Tool by Pivotal that looks for style keys in package.json of all node dependencies.
It will bundle this up with all the resources (fonts, images).
```dr-frankenstyle``` is used to generates dist/css/* for the SDK.

### cssify

A post install task copies css files needed from external components (such as react-table).
By using import statements to css files, browserify bundles up the css (but won’t copy any needed resources, so this only works for plain css).

```javascript
  import './FeatureTable.css';
```

## Debug server

Can be used by any SDK application, is part of the SDK tools. In ```package.json```:

```
  "@boundlessgeo/sdk-tools": "^0.10.0"
```

To use it in a node script file:

```javascript
var tools = require('@boundlessgeo/sdk-tools');
tools.startServer();
```

Any application generated by the ```web-sdk``` will facilitate this out of the box.

## Proxy to local geoserver

Add the following dependency to your ```package.json```:

```
"json-http-proxy": "^1.0.0-BETA-3",
```

To start the proxy, add a script to the ```package.json``` file:

```
"start:proxy": "json-http-proxy -p 4000",
```

Using ```npm run start:proxy``` will start up the proxy server on port 4000 using config from ```proxy-config.json```:

```json
{
  "routes": [
    {
      "path": "/geoserver/*",
      "upstream": "geoserver"
    },
    {
      "path": "/*",
      "upstream": "default"
    }
  ],
  "upstreams": {
    "geoserver": {
      "protocol": "http",
      "hostname": "localhost",
      "port": 8080
    },
    "default": {
      "port": 3000
    }
  }
}
```

This means in another shell you will need to start up the normal debug server on port 3000 using ```npm start```. The application should be accessed on http://localhost:4000 and will have a local proxy to GeoServer on port 8080 by default (http://localhost:4000/geoserver will proxy to http://localhost:8080/geoserver).
